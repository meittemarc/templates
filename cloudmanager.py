"""A top-level template which creates a FireCloud GCP project.

This is meant to be used as a composite type using the GCP Cloud Deployment
Manager. See the .py.schema file for more details on how to use the composite
type.
"""

GCP_REGIONS = ['europe-north1']

def iprange(number):
    return '10.' + str(number) + '.0.0/20'

#assign IP ranges programmatically, because typing them out terrifies me
FIRECLOUD_NETWORK_REGIONS = { region: iprange(128 + 2*i) for (i, region) in enumerate(GCP_REGIONS) }

FIRECLOUD_REQUIRED_APIS = [
    "compute.googleapis.com",
    "storage-api.googleapis.com"
]

FIRECLOUD_VPC_NETWORK_NAME = "network"
FIRECLOUD_VPC_SUBNETWORK_NAME = "subnetwork"

def create_default_network(context):
  """Creates a default VPC network resource.

  Args:
      context: the DM context object.

  Returns:
      A resource instantiating the network.py sub-template.
  """
  return [{
      'type': 'templates/network.py',
      'name': 'fc-network',
      'properties': {
          'resourceName': 'network',
          'name': 'network',
          'projectId': '$(ref.fc-project.projectId)',
          'autoCreateSubnetworks': True,
          # We pass the dependsOn list into the network template as a
          # parameter. Deployment Manager doesn't support dependsOn for
          # template-call nodes, so we can't have this resource itself depend on
          # the project-wide resources.
          'dependsOn': '$(ref.fc-project.resourceNames)',
      },
  }]


def create_high_security_network(context):
  """Creates a high-security VPC network resource.

  Args:
      context: the DM context object.

  Returns:
      A resource instantiating the network.py sub-template.
  """
  subnetworks = []
  for region in FIRECLOUD_NETWORK_REGIONS:
    subnetworks.append({
        # We append the region to the subnetwork's DM resource name, since
        # each resource name needs to be globally unique within the deployment.
        'resourceName': FIRECLOUD_VPC_SUBNETWORK_NAME + '_' + region,
        # We want all subnetworks to have the same object name, since this most
        # closely mirrors how auto-mode subnets work and is what PAPI expects.
        'name': FIRECLOUD_VPC_SUBNETWORK_NAME,
        'region': region,
        'ipCidrRange': FIRECLOUD_NETWORK_REGIONS[region],
        'enableFlowLogs': context.properties.get('enableFlowLogs', False),
    })

  return [{
      'type': 'templates/network.py',
      'name': 'fc-network',
      'properties': {
          'resourceName': 'network',
          'name': FIRECLOUD_VPC_NETWORK_NAME,
          'projectId': '$(ref.fc-project.projectId)',
          'autoCreateSubnetworks': False,
          'subnetworks': subnetworks,
          # We pass the dependsOn list into the network template as a
          # parameter. Deployment Manager doesn't support dependsOn for
          # template-call nodes, so we can't have this resource itself depend on
          # the project-wide resources.
          'dependsOn': '$(ref.fc-project.resourceNames)',
      },
  }]


def create_firewall(context):
  """Creates a VPC firewall config.

  The VPC firewall config depends on the VPC network having been completely
  instantiated, so it includes a dependsOn reference to the list of resources
  generated by the network sub-template.

  Args:
      context: the DM context object.

  Returns:
      A resource instantiating the firewall.py sub-template.
  """
  return [{
      'type': 'templates/firewall.py',
      'name': 'fc-firewall',
      'properties': {
          'projectId':
              '$(ref.fc-project.projectId)',
          'network':
              '$(ref.fc-network.selfLink)',
          'dependsOn':
              '$(ref.fc-network.resourceNames)',
          'rules': [
              {
                  'name': 'allow-icmp',
                  'description': 'Allow ICMP from anywhere.',
                  'allowed': [{
                      'IPProtocol': 'icmp',
                  }],
                  'direction': 'INGRESS',
                  'sourceRanges': ['0.0.0.0/0'],
                  'priority': 65534,
              },
              {
                  'name': 'allow-internal',
                  'description': 'Allow internal traffic on the network.',
                  'allowed': [{
                      'IPProtocol': 'icmp',
                  }, {
                      'IPProtocol': 'tcp',
                      'ports': ['0-65535'],
                  }, {
                      'IPProtocol': 'udp',
                      'ports': ['0-65535'],
                  }],
                  'direction': 'INGRESS',
                  'sourceRanges': ['10.128.0.0/9'],
                  'priority': 65534,
              },
              {
                  'name': 'leonardo-ssl',
                  'description': 'Allow SSL traffic from Leonardo-managed VMs.',
                  'allowed': [{
                      'IPProtocol': 'tcp',
                      'ports': ['443'],
                  }],
                  'direction': 'INGRESS',
                  'sourceRanges': ['0.0.0.0/0'],
                  'targetTags': ['leonardo'],
              },
          ],
      },
  }]


def create_iam_policies(context):
  """Creates a list of IAM policies for the new project.

  Arguments:
      context: the DM context object.

  Returns:
      A list of policy resource definitions.
  """
  policies = []

  # First, we pre-fill the policy list with Firecloud-wide role grants. These
  # include roles given to the Rawls / Cromwell service accounts, as well as the
  # global Firecloud project owners group (used for administration / maintenance
  # by Firecloud devops).
  fc_project_editors = []
  fc_project_owners = []

  if 'fcBillingGroup' in context.properties:
    fc_project_owners.append('group:{}'.format(
        context.properties['fcBillingGroup']))

  if 'fcProjectEditors' in context.properties:
    fc_project_editors.extend(context.properties['fcProjectEditors'])

  if 'fcProjectOwners' in context.properties:
    fc_project_owners.extend(context.properties['fcProjectOwners'])

  if fc_project_editors:
    policies.append({
        'role': 'roles/editor',
        'members': fc_project_editors,
    })

  if fc_project_owners:
    policies.append({
        'role': 'roles/owner',
        'members': fc_project_owners,
    })

  # Now we handle granting IAM permissions that apply to Firecloud-managed
  # owners and viewers. We generally expect the 'projectOwnersGroup' and
  # 'projectViewersGroup' to be non-empty, but this code handles an empty value
  # for either in case that changes in the future.
  #
  # This list is populated with both the FC project OWNERS proxy group and the
  # FC project VIEWERS proxy group.
  owners_and_viewers = []
  # This list will contain the OWNERS proxy group only.
  owners_only = []

  if 'projectOwnersGroup' in context.properties:
    owners_and_viewers.append('group:{}'.format(
        context.properties['projectOwnersGroup']))
    owners_only.append('group:{}'.format(
        context.properties['projectOwnersGroup']))

  if 'projectViewersGroup' in context.properties:
    owners_and_viewers.append('group:{}'.format(
        context.properties['projectViewersGroup']))

  if owners_only:
    policies.extend([
        {
            # Only FireCloud project owners are allowed to view the GCP project.
            'role': 'roles/viewer',
            'members': owners_only,
        },
        {
            # Owners can manage billing on the GCP project (to switch out
            # billing accounts).
            'role': 'roles/billing.projectManager',
            'members': owners_only,
        },
    ])

  if owners_and_viewers:
    policies.extend([
        {
            # Owners & viewers are allowed to spin up PAPI nodes in the
            # project (required for creating Leonardo notebooks).
            'role': 'roles/genomics.pipelinesRunner',
            'members': owners_and_viewers,
        },
        {
            # Owners & viewers are allowed to run BigQuery queries in the
            # project (required for running BQ queries within notebooks).
            'role': 'roles/bigquery.jobUser',
            'members': owners_and_viewers,
        },
    ])

  # The requester pays role is an organization-wide role ID that should be
  # granted to both project owners and viewers.
  if 'requesterPaysRole' in context.properties and owners_and_viewers:
    policies.append({
        'role': context.properties['requesterPaysRole'],
        'members': owners_and_viewers,
    })

  return policies


def create_pubsub_notification(context, depends_on, status_string):
  """Creates a resource to publish a message upon deployment completion.

  Arguments:
      context: the DM context object.
      depends_on: a list of resource names this notification should depend on.
      status_string: the "status" attribute value to publish, e.g. 'STARTED' or
        'COMPLETED'.

  Returns:
    A list of pubsub Deployment Manager actions.
  """

  return [{
      'name': 'pubsub-notification-{}'.format(status_string),
      'action': 'gcp-types/pubsub-v1:pubsub.projects.topics.publish',
      'properties': {
          'topic':
              context.properties['pubsubTopic'],
          'messages': [{
              'attributes': {
                  'projectId': context.properties['projectId'],
                  'status': status_string,
              }
          }]
      },
      'metadata': {
          # The notification should only run after *all* project-related
          # resources have been deployed.
          'dependsOn': depends_on,
          # Only trigger the pubsub message when the deployment is created (not on
          # update or delete).
          'runtimePolicy': ['UPDATE_ALWAYS'],
      },
  }]


def generate_config(context):
  """Entry point, called by deployment manager.

  Args:
      context: the Deployment Manager context object.

  Returns:
      A list of resources to be consumed by the Deployment Manager.
  """
  resources = []

  # Create an initial 'STARTED' pubsub notification.
  if 'pubsubTopic' in context.properties:
    resources.extend(
        create_pubsub_notification(
            context,
            depends_on=[],
            status_string='STARTED',
        ))

  # Required properties.
  billing_account_id = context.properties['billingAccountId']
  parent_organization = context.properties['parentOrganization']
  project_id = context.properties['projectId']

  # Optional properties, with defaults.
  high_security_network = context.properties.get('highSecurityNetwork', False)
  storage_bucket_lifecycle = context.properties.get('storageBucketLifecycle', 180)
  billing_account_friendly_name = context.properties.get('billingAccountFriendlyName', billing_account_id)
  # Use a project name if given, otherwise it's safe to fallback to use the
  # project ID as the name.
  project_name = context.properties.get('projectName', project_id)
  labels_obj = context.properties.get('labels', {})

  if high_security_network:
      labels_obj.update({
          "vpc-network-name" : FIRECLOUD_VPC_NETWORK_NAME,
          "vpc-subnetwork-name" : FIRECLOUD_VPC_SUBNETWORK_NAME
      })

  if 'parentFolder' in context.properties:
    parent_obj = {
        'id': context.properties['parentFolder'],
        'type': 'folder',
    }
  else:
    parent_obj = {
        'id': context.properties['parentOrganization'],
        'type': 'organization',
    }

  # Create the main project resource.
  resources.append({
      'type': 'templates/project.py',
      'name': 'fc-project',
      'properties': {
          'activateApis': FIRECLOUD_REQUIRED_APIS,
          'billingAccountId': billing_account_id,
         ## 'billingAccountFriendlyName': billing_account_friendly_name,
         ## 'iamPolicies': create_iam_policies(context),
          'labels': labels_obj,
          'name': project_name,
          # The project parent. For FireCloud, this should refer to the
          # firecloud.org (or equivalent) GCP organization ID.
          'parent': parent_obj,
          'projectId': project_id,
          # If true, this would remove the default compute egine service
          # account. FireCloud doesn't use this SA, but we're leaving this set
          # to False to avoid changing any legacy behavior, at least initially.
          'removeDefaultSA': False,
          # Removes the default VPC network for projects requiring stringent
          # network security configurations.
          'removeDefaultVPC': high_security_network,
          # Always set up a usage bucket export for FireCloud.
          'usageExportBucket': True,
          # Always set up the storage logs and cromwell auth buckets for Firecloud
          'storageLogsBucket': True,
          'storageBucketLifecycle': storage_bucket_lifecycle,
         ## 'cromwellAuthBucket': True
      }
  })

 # if high_security_network:
 #   resources.extend(create_high_security_network(context))
 #   resources.extend(create_firewall(context))
 # else:
 #   resources.extend(create_default_network(context))

 # if 'pubsubTopic' in context.properties:
 #   resources.extend(
 #       create_pubsub_notification(
 #           context,
            # This is somewhat hacky, but we can't simply collect the name of each
            # collected resource since template call nodes aren't "real" resources
            # that can be part of a dependsOn stanza. So instead, we collect the
            # names of all resources that are output by the network (which itself
            # depends on the project). It doesn't seem to be possible to concatenate
            # dependsOn arrays within the reference syntax, otherwise we could make
            # this depend explicitly on all resources from the template nodes.
 #           depends_on='$(ref.fc-network.resourceNames)',
 #           status_string='COMPLETED'))

  return {'resources': resources}
